<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.27">
    <title>面向对象和JS中的面向对象 | Jess Github</title><meta name="description" content="Jess Github">
    <link rel="preload" href="/blog/assets/js/runtime~app.c611790b.js" as="script"><link rel="preload" href="/blog/assets/css/styles.218d98f0.css" as="style"><link rel="preload" href="/blog/assets/js/812.ba3edf9c.js" as="script"><link rel="preload" href="/blog/assets/js/app.50e82b40.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/styles.218d98f0.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><!----><span class="site-name can-hide">Jess Github</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/blog/" class="nav-link" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/about" class="nav-link" aria-label="关于"><!--[--><!--]--> 关于 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/blog/" class="nav-link" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/blog/about" class="nav-link" aria-label="关于"><!--[--><!--]--> 关于 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><a href="/blog/JS/object" class="nav-link sidebar-heading sidebar-item active" aria-label="JS"><!--[--><!--]--> JS <!--[--><!--]--></a><ul class=""><li><!--[--><a href="/blog/main/JS/对象.md" class="nav-link sidebar-item active" aria-label="对象"><!--[--><!--]--> 对象 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="面向对象和js中的面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象和js中的面向对象" aria-hidden="true">#</a> 面向对象和JS中的面向对象</h1><h2 id="面向对象-《面向对象分析与设计》总结" tabindex="-1"><a class="header-anchor" href="#面向对象-《面向对象分析与设计》总结" aria-hidden="true">#</a> 面向对象 - 《面向对象分析与设计》总结</h2><ul><li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li><li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li><li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li></ul><h2 id="js对象的特征" tabindex="-1"><a class="header-anchor" href="#js对象的特征" aria-hidden="true">#</a> JS对象的特征</h2><ul><li><p>标识性：JS中对象都是通过内存地址来存储，一般别的语言也一样。</p></li><li><p>有状态，具有行为：JS中，将状态和行为统一抽象为属性，包括函数也式一种特殊对象。</p></li><li><p>JS对象中还有独有的特色：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</p></li></ul><h3 id="高度的动态性" tabindex="-1"><a class="header-anchor" href="#高度的动态性" aria-hidden="true">#</a> 高度的动态性</h3><ul><li><p>数据属性：比较接近于其它语言的属性概念</p><ul><li>value：就是属性的值。</li><li>writable：决定属性能否被赋值。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值。</li></ul></li><li><p>访问器属性：</p><ul><li>getter：函数或 undefined，在取属性值时被调用。</li><li>setter：函数或 undefined，在设置属性值时被调用。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值。</li></ul></li><li><p>可以通过<code>Object.getOwnPropertyDescripter</code>查看。</p></li></ul><h2 id="虽然js的对象系统设计很特别-但js也提供了完全运行时的对象系统-使得它可以模仿多数面向对象编程方式。" tabindex="-1"><a class="header-anchor" href="#虽然js的对象系统设计很特别-但js也提供了完全运行时的对象系统-使得它可以模仿多数面向对象编程方式。" aria-hidden="true">#</a> 虽然JS的对象系统设计很特别，但JS也提供了完全运行时的对象系统，使得它可以模仿多数面向对象编程方式。</h2><h2 id="javascript-语言标准也已经明确说明-javascript-是一门面向对象的语言" tabindex="-1"><a class="header-anchor" href="#javascript-语言标准也已经明确说明-javascript-是一门面向对象的语言" aria-hidden="true">#</a> JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言</h2><h1 id="面向对象不等于面向类" tabindex="-1"><a class="header-anchor" href="#面向对象不等于面向类" aria-hidden="true">#</a> 面向对象不等于面向类</h1><ul><li>JS之初，Brendan透露过，最初的构想是一个拥有基于原型的面向对象能力的scheme语言。</li><li>JS之前，原型系统久更多与高动态性语言配合，多数基于原型的语言提倡运行时的原型修改。</li><li>无论是基于类或者基于原型，都能够满足基本的复用和抽象需求</li></ul><h2 id="基于类" tabindex="-1"><a class="header-anchor" href="#基于类" aria-hidden="true">#</a> 基于类</h2><ul><li>编程提倡使用一个关注分类和类之间关系开发模型。总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。</li><li>类又往往与语言的类型系统整合，形成一定编译时的能力。</li></ul><h2 id="基于原型" tabindex="-1"><a class="header-anchor" href="#基于原型" aria-hidden="true">#</a> 基于原型</h2><ul><li><p>更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。</p></li><li><p>基于原型的面向对象系统通过“复制”的方式来创建新对象。</p></li><li><p>原型系统的复制操作，有两种实现思路</p><ul><li>一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；（JS）</li><li>另一个是切实地复制对象，从此两个对象再无关联。</li></ul></li></ul><h2 id="js的原型系统" tabindex="-1"><a class="header-anchor" href="#js的原型系统" aria-hidden="true">#</a> JS的原型系统</h2><ul><li><p>如果所有对象都有私有字段 [[prototype]]，就是对象的原型；</p></li><li><p>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</p></li><li><p>ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。「可以完全抛开类的思维，利用原型来实现抽象和复用。」</p><ul><li>Object.create 根据指定的原型创建新对象，原型可以是 null；</li><li>Object.getPrototypeOf 获得一个对象的原型；</li><li>Object.setPrototypeOf 设置一个对象的原型。</li></ul></li><li><p>在更早的版本中，程序员只能通过 Java 风格的类接口来操纵原型运行时，例如：<code>new, prototype</code></p></li></ul><h2 id="早期的类和原型" tabindex="-1"><a class="header-anchor" href="#早期的类和原型" aria-hidden="true">#</a> 早期的类和原型</h2><ul><li><p>在早期版本的 JavaScript 中，“类”的定义是一个私有属性 [[class]]。语言标准为内置类型诸如 Number、String、Date 等指定了 [[class]] 属性，以表示它们的类。语言使用者唯一可以访问 [[class]] 属性的方式是 Object.prototype.toString。</p></li><li><p>所以，在ES3 和之前的版本，JS 中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。</p></li><li><p>ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替。Object.prototype.toString 的意义从命名上不再跟 class 相关。（可以重写[Symbol.toStringTag]的方法）</p></li></ul><h3 id="关于类中的new" tabindex="-1"><a class="header-anchor" href="#关于类中的new" aria-hidden="true">#</a> 关于类中的new</h3><ul><li><p>做了什么事：</p><ul><li>new 运算接受一个构造器和一组调用参数</li><li>以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象</li><li>将 this 和调用参数传给构造器，执行；</li><li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li></ul></li><li><p>试图让函数对象在语法上和类变得类似，本质上new提供了两种方式：</p><ul><li>在构造器中添加属性。例如：直接在构造器中修改this，给this添加属性</li><li>二是在构造器的 prototype 属性上添加属性。修改构造器prototype属性指向的对象。</li></ul></li></ul><h3 id="es6中的类" tabindex="-1"><a class="header-anchor" href="#es6中的类" aria-hidden="true">#</a> ES6中的类</h3><ul><li><p>新特性 class 可以让 new 和 function 的搭配退休啦。</p></li><li><p>在标准中删除了所有 [[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施。</p></li><li><p>除了getter/setter 和 method外，还提供了继承能力。</p></li></ul><h1 id="对象分类" tabindex="-1"><a class="header-anchor" href="#对象分类" aria-hidden="true">#</a> 对象分类</h1><h2 id="宿主对象-由-javascript-宿主环境提供的对象。" tabindex="-1"><a class="header-anchor" href="#宿主对象-由-javascript-宿主环境提供的对象。" aria-hidden="true">#</a> 宿主对象：由 JavaScript 宿主环境提供的对象。</h2><h2 id="内置对象-由-javascript-语言提供的对象" tabindex="-1"><a class="header-anchor" href="#内置对象-由-javascript-语言提供的对象" aria-hidden="true">#</a> 内置对象：由 JavaScript 语言提供的对象:</h2><h3 id="固有对象-intrinsic-objects" tabindex="-1"><a class="header-anchor" href="#固有对象-intrinsic-objects" aria-hidden="true">#</a> 固有对象（Intrinsic Objects ）：</h3><ul><li>由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。通常扮演者类似基础库的角色。</li></ul><h3 id="原生对象-native-objects" tabindex="-1"><a class="header-anchor" href="#原生对象-native-objects" aria-hidden="true">#</a> 原生对象（Native Objects）：</h3><ul><li>可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象, 我们可以用 new 运算创建新的对象。</li><li><img src="/image/67da86dd816514b485a0b2f7dcb72dd.png" alt=""></li><li>几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承，由于这些构造器创建的对象多数使用了私有字段。所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。</li></ul><div class="language-JS ext-JS line-numbers-mode"><pre class="language-JS"><code>Error: [[ErrorData]]
Boolean: [[BooleanData]]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="普通对象-ordinary-objects" tabindex="-1"><a class="header-anchor" href="#普通对象-ordinary-objects" aria-hidden="true">#</a> 普通对象（Ordinary Objects）：</h3><ul><li>由 {} 语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</li></ul><h2 id="使用对象模拟函数与构造器" tabindex="-1"><a class="header-anchor" href="#使用对象模拟函数与构造器" aria-hidden="true">#</a> 使用对象模拟函数与构造器</h2><ul><li><p>函数对象的定义是：具有 [[call]] 私有字段的对象</p></li><li><p>构造器对象的定义是：具有私有字段 [[construct]] 的对象。</p></li><li><p>JS用对象模拟函数的设计替代了一般语言的函数，只要具有[[call]]私有字段，都可以被JS函数调用语法支持。</p><ul><li>PS：[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换</li></ul></li><li><p>用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。比如：</p><ul><li>内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串；</li><li>基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果</li></ul></li><li><p>ES6的箭头函数，创建的仅仅是函数，无法被作为构造器使用。</p></li></ul><h2 id="一些特殊行为的对象" tabindex="-1"><a class="header-anchor" href="#一些特殊行为的对象" aria-hidden="true">#</a> 一些特殊行为的对象</h2><ul><li>Array：Array 的 length 属性根据最大的下标自动发生变化。</li><li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li><li>String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。</li><li>Arguments：arguments 的非负整数型下标属性跟对应的变量联动。</li><li>模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><li>bind 后的 function：跟原来的函数相关联。</li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">2/7/2022, 10:12:24 AM</span></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 286980036@qq.com">JararisQ</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script src="/blog/assets/js/runtime~app.c611790b.js" defer></script><script src="/blog/assets/js/812.ba3edf9c.js" defer></script><script src="/blog/assets/js/app.50e82b40.js" defer></script>
  </body>
</html>
